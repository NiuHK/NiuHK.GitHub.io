{"posts":[{"title":"Windows 万能下载器 Aira2 懒人配置：","text":"Aria2 是一个命令行全功能下载器，同时支持磁力下载，没有原生界面但是可以使用aira2c以及airaNG的web界面 为什么选择 Aria2？ Aria2 下载功能比较全面，支持 BT 和磁力链接，性能也相当不错，速度不比迅雷慢。 虽然没有原生应用界面，配置也比较麻烦，但这些可以通过懒人包轻松解决。 最快速的懒人配置： 下载懒人包： LINK 将懒人包解压到 想要的文件夹，根据路径配置aria2.conf 官网下载 Aria2 程序LINK，然后解压到快速设置包的存放文件夹中，整体替代其中的 aria2相关程序和文件。 点击 Aria2c启动器.exeorAriaNg启动器.exe即可开始下载。两者都仅为前端界面，使用文件中的aria2.exe服务，可同时启动。包内均为开源绿色软件，不涉及任何隐私和安装，AutoHotkey 插件容易被误报。 Aria2c webui：https://aria2c.com/ AriaNg webui:file:///D:/Program/aria2/AriaNg/index.html#!/downloading 接管浏览器下载如果想用 Aria2 接管浏览器的下载管理，需安装插件/扩展。 Chrome：安装 添加到 aria2 扩展。下载包可以用 国内搬运地址，或是懒人包内置文件。如果浏览器无法直接安装 .crx 格式的扩展，可以将文件解压到新文件夹「xxx」，然后在浏览器的地址栏输入 chrome://extensions/ 开启开发者模式，点击加载已解压的扩展程序，选中刚才解压的文件夹「xxx」。 Firefox：安装 Aria2 Download Manager Integration 扩展，可参考下方的 Chrome 扩展设置进行配置。 安装完「添加到 aria2」扩展后，右键扩展图标，点击「选项」&gt;「设置」，设置如下： 最小监视：10 M，低于该容量将由浏览器下载。如果 Aria2 要接手所有下载，可以将最小监视设为 0.001。JSON-RPC 链接：http://localhost:6800/jsonrpc。注意：「添加到 aria2」图标显示的 en 表示处于开启状态，dis 表示处于关闭状态，点击图标可以切换使用状态。","link":"/2024/03/04/Aira2%20%E6%87%92%E4%BA%BA%E9%85%8D%E7%BD%AE/"},{"title":"Google服务异常耗电解决办法","text":"推荐root+gms doze.gms doze 卸载删不干净，还需要更改install.sh才能删除干净。gms doze 不工作则可能是系统或模块版本过低 原因：国内网状态下ping google服务器疯狂404并重试，导致占用率极大，手机温度达到温控阈值。 解决：1.gms doze（推荐）https://github.com/Magisk-Modules-Alt-Repo/GMSDoze 如果设备系统相同（lmi a13 pixel experience plus-2023-5-12），推荐使用，刷好后续航大幅度提升，配合scene的应用偏见功能完全可以将功耗发热降低至优于国内rom的水平 2.黑域动态gms: 有弹窗无法取消，并且root开机无法自启动，开发者给的答复是1.屏蔽弹窗消息不会支持。2.root不是主要支持，所以不会修。 3.universal gms doze：https://github.com/gloeyisk/universal-gms-doze 在我的设备（lmi a13 pixel experience plus-2023-5-12）不起作用 warning！模块由magisk刷入，所以能否卸载干净以及对设备的危害暂不知道！！！（底下的有人提出过相关issue，但是作者并未作答）","link":"/2023/06/30/Google%E6%9C%8D%E5%8A%A1%E5%BC%82%E5%B8%B8%E8%80%97%E7%94%B5%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"},{"title":"Icarus主题的一些常用配置","text":"常见的一些配置见_config.icarus.yml，英文不差都能看懂，或者去看icarus文档。本文主要就是一些网上很少的配置。 Icarus: 4.0.0 文章页面两栏布局在 _config.icarus.yml目录下，创建 _config.post.yml文件，该文件内容与 _config.icarus.yml文件一样，用于单独加载post界面布局。注意，双栏需要将widgets内容的position都设置为同一边。 12345678910111213141516171819202122232425262728# 单独文章界面布局widgets: # 个人信息 - position: left type: profile author: zhaommmmomo author_title: fahaxiki! location: Yantai,China avatar: /img/logo.jpg avatar_rounded: false follow_link: 'https://zhaommmmomo.cn' social_links: Github: icon: fab fa-github url: 'https://github.com/zhaommmmomo' # 文章目录 - position: left type: toc # 目录序号 index: true# 侧边栏是否固定sidebar: left: sticky: false right: sticky: false 增加两栏布局下文章的宽度12345678910111213141516171819202122232425262728# layout/layout.jsxmodule.exports = class extends Component { render() { ...... &lt;Head site={site} config={config} helper={helper} page={page} /&gt; # &lt;body class={`is-${columnCount}-column`}&gt; 修改为下面一行 &lt;body class={`is-3-column`}&gt; ...... # 'is-8-tablet is-8-desktop is-8-widescreen': columnCount === 2 # 修改为下面一行 'is-8-tablet is-8-desktop is-9-widescreen': columnCount === 2, 'is-8-tablet is-8-desktop is-6-widescreen': columnCount === 3 })} dangerouslySetInnerHTML={{ __html: body }}&gt;&lt;/div&gt; ...... }};# layout/common/widgets.jsxfunction getColumnSizeClass(columnCount) { switch (columnCount) { case 2: # return 'is-4-tablet is-4-desktop is-4-widescreen'; # 修改为下面一行 return 'is-4-tablet is-4-desktop is-3-widescreen'; case 3: return 'is-4-tablet is-4-desktop is-3-widescreen'; }} 只固定目录123456# source/js/main.jsconst $toc = $('#toc');if ($toc.length &gt; 0) { $toc.addClass('column-left is-sticky'); # 添加 ......} 1234# include/style/widget.styl 添加下面#toc max-height: calc(100vh - 22px) overflow-y: scroll","link":"/2024/03/09/Icarus%E4%B8%BB%E9%A2%98%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/"},{"title":"LLM 学习笔记","text":"大型语言模型（llm）是一种特殊的预训练语言模型，通过调整模型大小、预训练语料库和计算来获得。由于llm规模大，对大量文本数据进行预训练，表现出特殊的能力，能够在许多自然语言处理任务中不经过任何特定任务训练的情况下取得显著的性能。llm的时代始于OpenAI的GPT-3模型，在ChatGPT和GPT4等模型的引入后，llm的流行程度呈指数级增长。LLM 表现出根据相对较少量的提示或输入做出预测的非凡能力。LLM 可用于生成式人工智能，以根据采用人类语言的输入提示生成内容。 基于transformer架构的LLM：自注意力机制，关注词和当前输入序列的所有词的关系，提高训练速度 文本token化每个被一个整数表示 传入嵌入层，每个token被一个向量表示（词向量），向量空间中可以表示更多相关性（多维度） 位置编码代表词位置的位置向量与词向量组合，使模型同时理解词的意义以及在句中的关系 编码器（多级串联-&gt;更深入了解）多头自注意力机制-&gt; 词之间相关性表示权重 有多头自注意力机制，用来关注文本不同特征方面（动词、名词），并行运算互不影响，每个头的权重是训练中调整的。 位置编码的向量传入，加入自注意力机制的权重表示，输出（三种信息融合在向量里）向量。（同一个词，上下文不同表示不同） 前馈神经网络，增加模型表达能力 解码器（生成）一个特殊值（便于考虑之前已经生成的上文保持上下文连贯性）已生成的输出序列经过另一编码器，但使用 带掩码的多头自注意力机制，即自注意力头只关注当前词和其之前的词的关系权重， 确保解码器生成文本遵循正确时间顺序 编码器传出的向量（token的抽象表示）-&gt;多头自注意力 用来捕捉解码器即将产生成的输出以及编码器输入之间的关系，使输入序列信息融合到解码器输出中 前馈神经网络，增加模型表达能力 线性层，softmax层，转换解码器输出到词汇表概率分布（实现猜下一个词） 扩展仅解码器：掩码语言建模、情感分析 BERT 仅解码器：猜测上下文文本生成 GPT2、3 解码器解码器模型/ 序列到序列模型：翻译总结 T5、bart","link":"/2024/03/12/LLM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"MS_Office精简下载安装激活","text":"基于VL版本office的MS_Office精简下载安装激活 YouTube视频 下载官方部署器访问官方部署器地址：https://www.microsoft.com/en-us/download/details.aspx?id=49117 直接点击download，下载，并运行。 选择一空文件夹，完成程序。 下载部署自定义文件访问自定义网址：https://config.office.com/deploymentsettings 选择: 64位 批量许可证版本的office套件，对应的visio、project（这俩还看起来挺有用的，不用的话选择无）其他产品选择 语言包 应用-&gt;选择需要的项目 语言-&gt;选择中文 剩下的全部默认 导出-&gt;保留当前设置，命名为config 下载该文件，并导入当刚刚的文件夹中 下载、安装管理员cmd，cd到刚刚的文件夹 运行 setup /download config.xml 等待命令运行完毕（没有提示，等待弹出下一个输入框） 运行 setup /configure config.xml 等待安装完成，重启，看是否激活 未激活就管理员cmd格式下cd C:\\Program Files\\Microsoft Office\\Office16 重启并查看激活状态 还不行直接使用网上搜的kms激活VL版本office方法。","link":"/2024/03/24/MS-Office%E7%B2%BE%E7%AE%80%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E6%BF%80%E6%B4%BB/"},{"title":"c++ STL 库 （未完成）","text":"c++ STL 库包含基本的图，列表，栈等数据结构以及基本操作，方便使用。 结构图 set（集合） 内部自动有序 不含重复元素 容器 1234567#include &lt;set&gt;set&lt;int&gt; name;set&lt;double&gt; name;set&lt;char&gt; name;set&lt;struct node&gt; name;set&lt;set&lt;int&gt; &gt; name;//注意：&gt; &gt;之间要加空格set&lt;int&gt; arr[10]; set容器内元素的访问set只能通过迭代器(iterator)访问(除了vector和string之外的STL容器都不支持*(it+i)的访问方式) ： 12set&lt;int&gt;::iterator it;set&lt;char&gt;::iterator it; 1234for (set&lt;int&gt;::iterator it = st.begin(); it != st.end(); it++){ cout &lt;&lt; *it &lt;&lt; endl;} 常用函数insert(value)1st.insert('C'); find(value)find(value)返回的是set中value所对应的迭代器，也就是value的指针（地址） 1cout &lt;&lt; *(st.find(2)) &lt;&lt; endl; erase(it)1st.erase(st.find(100)); //利用find()函数找到100,然后用erase删除它 erase(iteratorBegin , iteratorEnd)左闭右开 1st.erase(it, st.end()); size()1cout &lt;&lt; st.size() &lt;&lt; endl; vector（矢量） 变长数组 123456789#include &lt;vector&gt;vector&lt;int&gt; name;vector&lt;double&gt; name;vector&lt;char&gt; name;vector&lt;struct node&gt; name;vector&lt;vector&lt;int&gt; &gt; name;//注意：&gt; &gt;之间要加空格vector&lt;int&gt; array[SZIE]; //二维变长数组 二维数组中，它的一维形式就是地址。例如： 12int arr[3][2];//定义一个3行2列的地址cout&lt;&lt;arr[0]&lt;&lt;endl; //输出arr第1行的地址 output: 10x61fe00 //arr第1行的地址 vector容器内元素的访问（1）通过下标访问 1cout&lt;&lt;vi[0]&lt;&lt;endl; （2）通过迭代器访问 迭代器（iterator）可以理解为指针 123456789101112131415161718192021222324vector&lt;类型名&gt;::iterator 变量名;vector&lt;int&gt;::iterator it;vector&lt;double&gt;::iterator it; vector&lt;int&gt;::iterator it=v.begin(); for (int i = 0; i &lt; v.size(); i++) { cout&lt;&lt;it[i]&lt;&lt;&quot; &quot;; } vector&lt;int&gt;::iterator it=v.begin(); for (int i = 0; i &lt; v.size(); i++) { cout&lt;&lt;*(it+i)&lt;&lt;&quot; &quot;; } //vector的迭代器不支持it&lt;v.end()的写法，因此循环条件只能it!=v.end() for (vector&lt;int&gt;::iterator it=v.begin(); it!=v.end();it++) { cout&lt;&lt;*it&lt;&lt;&quot; &quot;; } vector常用函数实例解析（1）push_back(item)1v.push_back(i); （2）void pop_back()1v.push_back(i); （3）size()1cout&lt;&lt;v.size()&lt;&lt;endl; （4）clear()1v.clear(); （5）insert()123insert(__position,__x);v.insert(v.begin()+2,-1); //将-1插入v[2]的位置 （6）erase() 左闭右开12345erase(__position); //删除一个元素 v.erase(v.begin()+3);erase(__positionBegin,__positionEnd);//删除一个区间内的元素 v.erase(v.begin()+1,v.begin()+4);","link":"/2024/02/28/c++%20STL%20%E5%BA%93/"},{"title":"sym","text":"","link":"/2024/03/11/sym/"},{"title":"Verilog running in vscode","text":"尝试在vscode跑Verilog，记录一下。很久之前设置的，想到多少写多少吧： 一·添加的扩展：Verilog HDL：添加一个运行按钮，添加控制台输出（大概） Verilog Snippet：关键词高亮补全（大概） Verilog_Testbench：自动生成测试文件，用处不大。 Verilog-HDL/SystemVe：主要的，综合各个模块 WaveTrace：波形显示 二·部分设置：&quot;verilog.linting.linter&quot;: &quot;iverilog&quot; 三·报错：1.include 报错：`include “./my.v”找不到文件，使用相对绝对路径都不行：设置为：&quot;verilog.linting.iverilog.runAtFileLocation&quot;: true","link":"/2023/10/18/verilog-in-vscode/"},{"title":"【UltraISO】中文破解版","text":"UltraISO 中文破解版 下载链接以及激活码 下载链接：https://cn.ultraiso.net/uiso9_cn.exe 简体中文版专用： 12注册名：Guanjiu注册码：A06C-83A7-701D-6CFC 多国语言版专用: 12注册名: Home注册码: 4BA9-0D54-214A-C938","link":"/2024/03/23/%E3%80%90UltraISO%E3%80%91%E4%B8%AD%E6%96%87%E7%A0%B4%E8%A7%A3%E7%89%88/"},{"title":"c++ &amp; Linux 操作系统进程相关操作","text":"实现进程管理协同 fork()pipe() 实现进程通信 每个进程各自有不同的用户地址空间,任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核,在内核中开辟一块缓冲区,进程A把数据从用户空间拷到内核缓冲区,进程B再从内核缓冲区把数据读走,内核提供的这种机制称为进程间通信。 API函数的使用以及注意点12#include &lt;unistd.h&gt;int pipe(int pipefd[2]); 参数说明： fd为文件描述符数组，其中fd[0]表示读端，fd[1] 表示写端 返回值： 成功返回0，失败返回-1，并且设置errno。 注意点： 管道内 没有数据时，读端（read）发生 阻塞，等待有效数据进行读取 管道容量被 数据填满时，写端（write）发生阻塞，等待进程将数据读走再进行写入 如果所有管道 写端对应的文件描述符被关闭，read返回0，但会将之前管道里的数据读完 如果所有管道的 读端对应的文件描述符被关闭，write操作会产生信号，SIGPIPE,进而导致write进程退出 当要写入的数据量不大于管道的容量（PIPE_BUF）时，linux将保证写入的原子性 当要写入的数据量大于管道容量(PIPE_BUF)时，linux将不再保证写入的原子性 fork子进程并使用pipe通信>folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;sys/wait.h&gt;using namespace std;int main() { int pipe_fd[2]; // 0 for reading, 1 for writing pid_t cpid; char buf; // 创建管道 if (pipe(pipe_fd) == -1) { perror(&quot;pipe&quot;); } for (int i = 0; i &lt; 4; ++i) { cpid = fork(); if (cpid == -1) { perror(&quot;fork&quot;); } if (cpid == 0) { // 子进程 close(pipe_fd[0]); // 关闭读端 // 发送消息 string message = &quot;Child &quot; + to_string(getpid()) + &quot; is sending a message to parent!\\n&quot;; write(pipe_fd[1], message.c_str(), message.length()); close(pipe_fd[1]); // 发送完毕，关闭写端 } else { // 父进程不立即关闭管道，等待所有子进程发送完毕 } } // 父进程读取数据 close(pipe_fd[1]); // 关闭写端 while (read(pipe_fd[0], &amp;buf, 1) &gt; 0) { write(STDOUT_FILENO, &amp;buf, 1); } close(pipe_fd[0]); // 关闭读端 // 等待所有子进程退出 for (int i = 0; i &lt; 4; ++i) { wait(NULL); } return 0;} shmget() shmat() shmdt() shmctl() 实现进程间数据同步 int shmget(key_t key, size_t size, int shmflg); 目的：用于创建新的共享内存段或访问一个已存在的共享内存段。 void *shmat(int shmid, const void *shmaddr, int shmflg); 目的：将共享内存段附加到调用进程的地址空间。 int shmdt(const void *shmaddr); 目的：将共享内存段从当前进程的地址空间分离。 int shmctl(int shmid, int cmd, struct shmid_ds *buf); 目的：对共享内存段执行各种控制操作。 示例程序./2.cpp: >folded12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;#include &lt;cstring&gt;#include &lt;unistd.h&gt;#define SHM_SIZE 512 // 定义共享内存的大小int main() { key_t key = ftok(&quot;shmfile&quot;,65); // 生成唯一键 int shmid = shmget(key, SHM_SIZE, 0666|IPC_CREAT); // 创建共享内存 if (shmid == -1) { perror(&quot;shmget&quot;); exit(1); } // 将共享内存附加到进程的地址空间 char *data = (char*) shmat(shmid, (void*)0, 0); if (data == (char*)(-1)) { perror(&quot;shmat&quot;); exit(1); } // 等待进程B写入数据 std::cout &lt;&lt; &quot;Waiting for process B to write data...\\n&quot;; sleep(5); // 简单的同步机制，等待几秒 // 显示共享内存中的数据 std::cout &lt;&lt; &quot;Data read from shared memory: &quot; &lt;&lt; data &lt;&lt; std::endl; // 分离共享内存 if (shmdt(data) == -1) { perror(&quot;shmdt&quot;); exit(1); } // 删除共享内存 shmctl(shmid, IPC_RMID, NULL); return 0;} ./2.1.cpp: >folded123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;#include &lt;cstring&gt;#define SHM_SIZE 512 // 定义共享内存的大小int main() { key_t key = ftok(&quot;shmfile&quot;,65); // 生成唯一键 int shmid = shmget(key, SHM_SIZE, 0666); // 访问共享内存 if (shmid == -1) { perror(&quot;shmget&quot;); exit(1); } // 将共享内存附加到进程的地址空间 char *data = (char*) shmat(shmid, (void*)0, 0); if (data == (char*)(-1)) { perror(&quot;shmat&quot;); exit(1); } // 向共享内存写入数据 std::cout &lt;&lt; &quot;Writing to shared memory\\n&quot;; std::strncpy(data, &quot;Hello from process B!&quot;, SHM_SIZE); // 分离共享内存 if (shmdt(data) == -1) { perror(&quot;shmdt&quot;); exit(1); } return 0;}","link":"/2024/03/22/linux-cpp-progress/"},{"title":"从C++到python","text":"python的优点是简单易学，库安装简单配置丰富，写法简洁，本文目的即初步认识python的规则化写法。 环境安装 进入’https://www.jetbrains.com/pycharm/‘ 下载pycharm并安装。 根据引导安装应用并登录，创建你的第一段python代码。 差异 毋庸置疑，py比cpp更简单，写代码形式上亦是如此，大体上差别如下： 不需要头文件 主函数没有函数名 不需要{} 不需要; 接下来，从最简单的输出开始； 基本知识输入输出输出函数print()语法就是： 1print() 输入函数是 input()，功能是接收用户输入的内容，语法是： 1input（输出的内容） 举例：接收用户输入的密码并打印: 12n = input(&quot;请输入密码：&quot;) #把输入内容赋给n，用 n 接收一下print(n) #打印n 在Python里，“#” 表示注释，“#”后面的东西不会被执行。 123提示信息请输入密码：123123 变量 合法的标识符:大小写字母，数字(不能开头),下划线。 没有长度限制。 建议望文生义，函数名、变量名等命名方法各有区分： 123451. 包名：全小写，例如 time ;2. 类名：每个单词的首字母大写，其他的小写，简称大驼峰命名，例如 HelloWorld ；3. 变量名/函数名:第一个单词的首字母小写，后面的单词的首字母大写，简称小驼峰命名，例如 helloWorld ；4. 常量：全大写，例如 HELLO 。5. 其他命名方式，比如 hello_world 。 数据类型与c++不同，python不需要类型说明符，在设置时会自行分配。（不是没有!!!） 整型 浮点型 字符串 bool类型 None 是一个单独的数据类型 列表、元组、字典、集合也是常见的数据类型 类型转换：123int() #被转换的必须为全数字的字符串str()float() #被转换的必须为全数字的字符串 获取类型信息1234type() #返回的是对象的类型type().__name__sinstance(,) #常用来判断数据类型,返回bool 例子：1234f = 30print(type(f))print(type(f).__name__) print(isinstance(f,int)) 输出：1234f = 30print(type(f))print(type(f).__name__)print(isinstance(f,float)) 运算符运算符可以分为很多4类 一般运算符 +，-，*，/（真除法）,//（地板除，舍去小数部分）,%（取余数）,**（幂运算） 赋值运算符 =,+=，-=，*=，/=,%=,**=连续赋值：a=b=c=d=10 布尔运算符 == （等于），！=（不等于）, &gt;= ,&lt;= ,&gt;, &lt; 4.逻辑运算符 主要有not、and和or三类，又称非、与和或 and：前后都为真则为真or：有一个为真则为真not:非真，非假 例子： 12345678a = 10b = 20c = 30d = 40n1 = a &gt; b and a &lt; c #a&gt;b为假，a&lt;c为真，假与真为假n2 = not a &lt; c #a&lt;c为真，非真则为假n3 = a &gt; b or a &lt; c #a&gt;b为假，a&lt;c为真，假或真为真print(n1,n2,n3) 输出; 1False False True 流程控制条件分支 (if elif else)例子： 12345678910111213s = int(input(&quot;请输入分数:&quot;))if 80 &gt;= s &gt;= 60: print(&quot;及格&quot;)elif 80 &lt; s &lt;= 90: print(&quot;优秀&quot;)elif 90 &lt; s &lt;= 100: print(&quot;非常优秀&quot;)else: print(&quot;不及格&quot;) if s &gt; 50: print(&quot;你的分数在60分左右&quot;) else: print(&quot;你的分数低于50分&quot;) 输出： 123请输入分数:55不及格你的分数在60分左右 循环流程 while循环 语法： 12while 布尔表达式: 代码块 只要条件(布尔表达式)为真就执行里面的代码块。 举例：比如说输入一个整数并计算各个位和，例如输入321，那么各个位之和则为6。 12345678910111213# 请输入一个整数，并计算各个位和 如：321=6n = int(input(&quot;请输入一个整数:&quot;)) # 将字符串转为整型# sums累加器：m=10 m=10+5sums = 0while n != 0: # 32 #3 sums = sums + n % 10 # sums=1+2=3+3=6 n = n // 10 # 32print(sums) 输出： 12请输入一个整数:234514 for循环 语法： 12for 变量 in 可迭代对象: 代码块 例子： 123l=[3,2,1]for n in l: print(&quot;1&quot;) 输出： 123111 range for循环经常会搭配range来使用，range是一个可迭代对象，range的语法如下： 1range(start=0,stop,step=1) Range对象返回一个对象，该对象按步生成从开始(包含)到结束(排除)的整数序列。Range (i, j)产生i, i+1, i+2，…j - 1。Start默认为0,stop省略! Range(4)产生0,1,2,3。这些正是包含4个元素的列表的有效索引。 当给出step时，它指定增量(或减量)。 continue break continue跳过本次循环，后面的循环继续执行break终止循环 列表(List)列表是可以同时存放任何数据，包括整型，浮点型，字符串，布尔型等等，是常用的数据类型之一。 列表的创建123456789列表也是一个可迭代对象1. 普通形式 l = [1,2,3,4,5] ---整型列表 l = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;] ---字符串列表 l = [True,False,1&gt;2,5&lt;6]---布尔列表2. 混合列表 l = [1,2.5,&quot;a&quot;,True]3. 空列表 l = [] 从列表中获取数据列表是有下标的，并且下标从0开始，获取方法类似数组但是列表的下标正序从0开始，倒叙从-1开始 print(List)顺序输出整个列表 列表中数据交换例子： 123l = [1, 2, 3, 4, 5] # 下标/索引：0开始l[2], l[3] = l[3], l[2]print(l) Output: 1[1, 2, 4, 3, 5] 向列表添加元素123append(project) #列表尾插对象（作为整体）extend(project) #列表尾插可迭代对象 eg：两列表相连接insert(num,project) #指定下标位置添加对象（作为整体） 列表删除元素1234clear()#清空列表（列表还在，没被删除）pop()#删除下标指定的元素，如果不加下标则删除最后一个元素remove()#删除（正序第一个）指定的对象del()#删除变量(整个列表)或列表指定下标元素的值（补位） 例子: 12345678910111213141516171819l = [1, 2, 3, 4, 5]l2=[6, 7, 8, 9, 10]l.extend(l2)print(l)l.append(l2)print(l)l.insert(3,l2)print(l)l.pop(1)print(l)l.remove(l2)print(l)del l[-1]print(l)del lprint(l2)l2.clear()print(l2) Output 12345678[1, 2, 3, 4, 5, 6, 7, 8, 9, 10][1, 2, 3, 4, 5, 6, 7, 8, 9, 10, [6, 7, 8, 9, 10]][1, 2, 3, [6, 7, 8, 9, 10], 4, 5, 6, 7, 8, 9, 10, [6, 7, 8, 9, 10]][1, 3, [6, 7, 8, 9, 10], 4, 5, 6, 7, 8, 9, 10, [6, 7, 8, 9, 10]][1, 3, 4, 5, 6, 7, 8, 9, 10, [6, 7, 8, 9, 10]][1, 3, 4, 5, 6, 7, 8, 9, 10][6, 7, 8, 9, 10][] 修改元素同数组。 列表高级特性切片操作切片，顾名思义就是把1个列表切分为多个列表，语法如下： 1变量[起始下标:结束下标] #结束下标取不到 做切片操作时要注意以下几个点： 如果下标从0开始可以省略不写，例如 n = l[:4]。 如果结束下标取的是最后一个元素，可以省略不写，例如 n = l[3:]。 如果列表中的元素都要，开始和结束下标都可以省略，例如 n = l[:]。 n = l[:-1] 表示从0开始 - 到数二个元素。例子： 12l = [1, 2, 3, 4, 5]print(l[0:4]) Output 1[1, 2, 3, 4] 等距抽取方法是 n = l[开始:结束:步长] ，这个方法既可以正向去操作列表，也可以反向去操作列表,例如: 123l = [1, 2, 3, 4, 5]n = l[-1:-3:-1]print(n) Output 1[5, 4] 列表的一些操作符比较运算符列表之间进行比较，以相同下标进行比较，从小到大进行比较，如果值相同则比较下一组元素，如果不同直接出结果，例如： 123l = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] # 下标/索引：0开始l2 = [2, 3, 4, 6]print(l &lt; l2) # True Output 1True 逻辑运算符逻辑运算符and not or 跟比较运算符相似，返回结果都是布尔值（True/False） 拼接运算符拼接运算符是 + ，常用来进行两个列表拼接 123l = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] # 下标/索引：0开始l2 = [2, 3, 4, 6]print(l + l2) 重复操作符重复操作符为 * ，后面常跟数字，表示将列表里面的元素重复复制几遍 12l2 = [2, 3, 4, 6]print(l2*2) 成员关系操作符成员关系操作符主要有 in和not in，用来判断元素是否在列表中，返回结果是布尔值 12l = [2, 3, 4, 6]print(5 not in l) #输出“5不在列表l中”这句话的真假 执行结果 1True 列表的其他方法123456copy()#浅拷贝count(project)#返回对象在列表中出现的次数index(value,开始下标,结束下标)#元素出现的第一次下标位置，也可自定义范围reverse()#原地翻转sort (key=None reverse=False)#快速排序，默认从小到大排序，key:算法len()#获取列表长度 二维列表12345#变量[外层列表下标][内层列表的下标]l = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]for i in l: for j in i: print(j) Output 123456789123456789 元组（tuple）元组的创建及访问 元组用（）的形式，是可迭代对象，是有序的，下标操作,支持切面操作 [:]同列表，不再赘述。 修改和删除元组是不可变类型，不能修改，但是可以通过将元组转换成列表的形式进行修改和删除等操作，最后再将列表转换成元组，完成元组的修改和删除。例如：修改元组中的元素: 1234567t = (1, 2, 3, 4, 5)l = list(t) #将元组转换成列表print(l) #输出列表l[2] = 6 #列表指定元素的修改print(l) #输出新列表t = tuple(l) #列表转换成元组print(t) Output 123[1, 2, 3, 4, 5][1, 2, 6, 4, 5](1, 2, 6, 4, 5) 元组的操作符元组同样也有着操作符，方法跟列表的操作符是一样的,不再赘述。 元组的方法对其操作先转换成列表再行操作，不再赘述。另外有两种方法新增： 123451. count(value)#统计某个值出现的次数，value是指定的值2. index(value,[start],[stop])#返回value在元组中(start到stop间)出现的下标位置（第一次出现的下标） 字符串在Python中，字符和字符串没有区别。可用' '也可以是” “ 字符串的特点1234567891. 字符串不可变类型2. 字符串是可迭代对象3. 字符串支持索引和切片操作4. 支持操作符; 拼接：+ 重复操作符：* 比较运算符： &gt; &lt; &lt;= &gt;= == != 逻辑运算符：not and or 成员关系： in not in 字符串的方法123456789capitalize()#把字符串的第一个字符改为大写，后面的小写casefold()#把整个字符串都小写encode()#编码 str--bytes (二进制字符串)decode()#解码count(sub,start, stop)#返回字符(sub)出现的次数，star: 开始下标，stop:结束下标find(sub,start,stop)# 返回sub第一次出现的下标,查不到返回-1index(sub, start, stop)#返回sub第一次出现的下标，查不到报错upper()#将字符串转为大写1ower()#将字符串转为小写 格式化输出 format 语法1：用数字占位（下标）12345&quot;{0} 嘿嘿&quot;.format(&quot;Python&quot;)a = 100s = &quot;{0}{1}{2} 嘿嘿&quot;s2 = s.format(a, &quot;JAVA&quot;, &quot;C++&quot;)print(s2) 2.format 语法2：{} 占位123456a = 100s = &quot;{}{}{} 嘿嘿&quot;s2 = s.format(a, &quot;JAVA&quot;, &quot;C++&quot;, &quot;C# &quot;)print(s2)#Output100JAVAC++ 嘿嘿 3.format 语法3：{} 占位用字母占位12345s = &quot;{a}{b}{c} 嘿嘿&quot;s2 = s.format(b=&quot;JAVA&quot;, a=&quot;C++&quot;, c=&quot;C# &quot;)print(s2)#Output:C++JAVAC# 嘿嘿 s.format(s2)可理解为使用s格式化s2 4.%s 语法为 “%s”%（值） ，最常用的参数可以是任意值。例子： 123456789101112131415for i in range(1, 10): for j in range(1, i + 1): print(&quot;%s * %s = %s&quot; % (i, j, i * j), end=&quot;\\t&quot;) print()#Output:1 * 1 = 1 2 * 1 = 2 2 * 2 = 4 3 * 1 = 3 3 * 2 = 6 3 * 3 = 9 4 * 1 = 4 4 * 2 = 8 4 * 3 = 12 4 * 4 = 16 5 * 1 = 5 5 * 2 = 10 5 * 3 = 15 5 * 4 = 20 5 * 5 = 25 6 * 1 = 6 6 * 2 = 12 6 * 3 = 18 6 * 4 = 24 6 * 5 = 30 6 * 6 = 36 7 * 1 = 7 7 * 2 = 14 7 * 3 = 21 7 * 4 = 28 7 * 5 = 35 7 * 6 = 42 7 * 7 = 49 8 * 1 = 8 8 * 2 = 16 8 * 3 = 24 8 * 4 = 32 8 * 5 = 40 8 * 6 = 48 8 * 7 = 56 8 * 8 = 64 9 * 1 = 9 9 * 2 = 18 9 * 3 = 27 9 * 4 = 36 9 * 5 = 45 9 * 6 = 54 9 * 7 = 63 9 * 8 = 72 9 * 9 = 81 转义字符12341. “\\n” ：换行符2. “\\'”:单引号3. “\\“”:双引号4. &quot;\\\\&quot; : \\ 在这里值得注意的是 \\ ，它有很多比较巧的运用，比如可以实现代码换行 12345678910111213a = &quot;sxsxsxsxsxsxsxs\\ xsxsxsxs\\ xsx&quot;print(a)a = 1 + 2 + 3 \\ + 4print(a)#Output:sxsxsxsxsxsxsxs xsxsxsxs xsx10 字典（dict）字典是用来存储数据的，字典中的数据以映射关系存储。 字典的特点 字典是Python中唯一的映射类型 字典是无序的 字典是可迭代对象 字典的构成: 键：key 值：value 映射：键映射值 键-值：键值对，又叫 项 创建字典1234561. 直接创建 语法： d = {} #空字典 例如： d = {&quot;name&quot;:&quot;不良人&quot;,&quot;apple&quot;:&quot;苹果&quot;}2. dict() 例如：d = dict() #空字典3. dict(可迭代对象) 例子： 1234d3 = dict([(&quot;one&quot;,1),(&quot;two&quot;,2)])print(d3)#Output：{'one': 1, 'two': 2} 这就是一个元组，one是键，1是值， ‘one’ : 1 是键值对。 14. dict(**kwargs) 例子： 1234d4 = dict(a=3, b=4)print(d4)#Output:{'a': 3, 'b': 4} 字典访问 基本形式： 变量名[键名] #键所对应的值 添加一个键值对 变量名[键名]=值 修改一个键值对的值 变量名[键名]=值 Example 1234d = {&quot;name&quot;: &quot;小黑&quot;}print(d[&quot;name&quot;])#Output:小黑 字典的方法","link":"/2023/07/01/%E4%BB%8EC-%E5%88%B0python/"},{"title":"使用giscus为blog添加评论系统","text":"giscus指一个非常好用的由GitHub讨论支持的评论系统，它可以让你把仓库中的讨论整合到你的博客中。 如何使用 GitHub 讨论作为聊天系统为了将GitHub讨论整合到你的博客，我们将使用 giscus。giscus是一个由GitHub讨论支持的评论系统。它可以让你把仓库中的讨论整合到你的博客中。 你的读者可以在你的博客上留下评论，这些评论会同时出现在你的博客和你的代码库的讨论页面上。 使用讨论区作为你的博客聊天系统的优势 它是完全免费的 没有广告或跟踪 它超级强大 你对评论有完全的控制权和完全的修改权。 有很多主题 它是相当可自定义的 你可以在你自己的服务器上自行托管 请记住，此工具主要适用于开发者博客，因为大多数开发人员使用 GitHub。 如何在你的博客中整合giscus先决条件 一个博客（你必须能够获得源代码） 一个 GitHub 帐户 你选择的代码库必须是公开的 首先，你需要为你的代码库启用讨论功能。 转到代码库 Settings-&gt; 在 Features部分下 -&gt; 勾选 Discussions框。接下来，在你的代码库中安装giscus应用程序。转到 giscus主页，按照提示操作，并仅授予对选定代码库的访问权限。现在是重要的部分：我们需要配置giscus小部件。 首先，进入giscus主页，滚动到 Configuration部分。 选择您的小部件语言，这是您想要显示小部件的语言。然后输入你的代码库名称和你的用户名，如用 username/reponame。对于页面↔️讨论映射，我建议选择 “讨论标题包含页面 URL”。但根据你的需要，选择最适合你的那一个。接下来，在你的GitHub 代码库上的讨论页面创建一个类别——比如 “Comments（评论）”——或者选择现有的类别。然后根据需要启用可选功能。 接下来，选择主题。不要担心，你可以通过编程来切换不同的主题。 最后，复制并粘贴生成的代码。 Giscus将根据你的设置生成一个脚本标签，你可以将其粘贴到你的代码中。","link":"/2024/03/08/%E4%BD%BF%E7%94%A8giscus%E4%B8%BAblog%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/"},{"title":"使用github codespace + github page + hexo 无服务器发布运行个人博客","text":"hexo是一个可以github page 托管的静态页面博客框架，需要node.js进行编译发布，鉴于windows配置node.js的不变性，使用github codespace托管运行环境以及博客源码，进行无服务器博客运营。 icarus 主题 整体颜色改变：/node_modules/hexo-theme-icarus/include/style/base.styll15 $primary ?= hsl(30, 100%, 50%) 更改两栏布局下文章宽度 部分更改 调整背景透明度themes\\icarus\\source\\js\\animation.jsL44 https://blog.mchook.cn/2021/07/22/icarus%E4%B8%BB%E9%A2%98%E8%87%AA%E5%AE%9A%E4%B9%89/https://blog.pk5ls20.com/posts/111d57cd/#span-%E8%83%8C%E6%99%AF%E5%9B%BE%E5%85%A8%E5%B1%8F%E5%8C%96-%E6%AF%9B%E7%8E%BB%E7%92%83%E6%95%88%E6%9E%9C-span 我使用的布局：.is-3-colum 可以在Markdown文件中使用下面的语法来折叠单独的代码块： 123{% codeblock &quot;可选文件名&quot; lang:代码语言 &gt;folded %}...代码块内容...{% endcodeblock %}","link":"/2024/03/08/%E4%BD%BF%E7%94%A8github-codespace-github-page-hexo-%E7%BA%BF%E4%B8%8A%E7%BC%96%E8%BE%91%E5%8F%91%E5%B8%83%E8%BF%90%E8%A1%8C%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"title":"基于quatrus的verilog学习","text":"quartus是一个配置麻烦的硬件编程平台，本文包括安装配置到常见问题解答，环境优化。 quatrus安装以及modelsim配置 quatrus 不操作 modism.exe 的文件夹加入到path modism文件夹下，win64下 LISCENSE.TXT 加入到 path（user） tools-&gt;options-&gt;general-&gt;eda tools 中设置modelsim路径D:\\Program\\modeltech64_10.4\\win64（exe路径文件夹） 常见问题解决以及优化设置编译器件库位置（新项目都需要）同时也解决了 Quartus Prime18.0 中解决仿真报错 Error: (vsim-19) Failed to access library 的问题 点击Tools-&gt;Launch Simulation Library Compile; 设置“Output directory&quot;为：{项目文件夹}/simulation/qsim，在进行编译,如此设置以后，波形图simulation-&gt;simulation settings中的路径直接默认就行 （主要是这里编译的器件库路径要匹配波形图simulation-&gt;simulation settings中的路径） 联合vscode开发点击tools中的options，点击其中的 preferred text editor，在 textx editor栏中选择custom，在command-line中添加如下的信息&quot;E:\\Microsoft VS Code\\Code.exe&quot; -r -g %f:%l","link":"/2024/03/28/%E5%9F%BA%E4%BA%8Equatrus%E7%9A%84verilog%E5%AD%A6%E4%B9%A0/"},{"title":"大学生创新创业大赛筹备","text":"备忘录，筹备答辩24/03/11 研究目的及研究内容研究目的 现在存在的研究的问题 本项目的改进点、创新点 研究内容结构图，简单概括PIC 国内外发展动态 传统方法，缺点介绍 近年发展3，本项目技术优点 项目创新点项目整体的优势 项目技术路线PIC整体路线分点介绍，小点实现 项目进度安排PIC 经费，小小展示一下表格 预期成果总结（结题）报告发论文专利（软著） 列一下就行 项目团队及已有基础 指导老师介绍（详细） 项目成员介绍 已有基础 已取得成绩 ：初步了解、初步确定、目前正在… 已具备实验条件：软件、数据集、老师可提供的帮助、硬件环境 答辩视频","link":"/2024/03/11/%E5%A4%A7%E5%AD%A6%E7%94%9F%E5%88%9B%E6%96%B0%E5%88%9B%E4%B8%9A%E5%A4%A7%E8%B5%9B%E7%AD%B9%E5%A4%87/"},{"title":"AcWing 796.子矩阵的和","text":"AcWing 796.子矩阵的和 第二层矩阵存当前（0，0）-（x，y）和，求x1yx1-x2y2类似于求面积可理解为坡度(大概) 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;string&gt;#include&lt;iomanip&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;vector&gt;#include&lt;set&gt;using namespace std;typedef long long ll;const int N=100010;ll v[N][1000][2]={0};int main(){ int n,m,q; cin&gt;&gt;n&gt;&gt;m&gt;&gt;q; for(int j=1;j&lt;=n;j++){ for(int i=1;i&lt;=m;i++){ cin&gt;&gt;v[j][i][0]; v[j][i][1]=v[j-1][i][1]+v[j][i-1][1]-v[j-1][i-1][1]+v[j][i][0]; } } int x1,y1,x2,y2,count; for(int i=0;i&lt;q;i++){ count=0; cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2; ll count=v[x2][y2][1]-v[x2][y1-1][1]-v[x1-1][y2][1]+v[x1-1][y1-1][1]; cout&lt;&lt;count&lt;&lt;endl; }}","link":"/2024/03/18/%E5%AD%90%E7%9F%A9%E9%98%B5%E7%9A%84%E5%92%8C/"},{"title":"样式测试","text":"这是一个简单的样式测试页面 主题1主题2主题3主题4主题5细细细细 粗体粗体粗体粗体粗体 细细细细细细 斜体斜体 删除删除删除删除删除 下划线下划线下划线下划线 引用引用引用引用 hangneidaima行内代码` 12345代码块代码块代码块代码块代码块代码块 无序列表 无序列表 无序列表 无序列表、 有序列表 有序列表 有序列表 有序列表 链接链接链接链接 @提及提及提及提及提及","link":"/2024/03/07/%E6%A0%B7%E5%BC%8F%E6%B5%8B%E8%AF%95/"},{"title":"计算机组成原理笔记","text":"计算机组成原理笔记 Chapter4 指令系统指令格式设计基本结构 操作码 源操作数/其地址or立即数：储存单元地址/寄存器编号/io端口 结果的地址：储存单元地址/寄存器编号/io端口 下条地址：通常隐含在PC中（按顺序执行时，下条地址为PC+地址长度）转移指令则跳转到给出的地址。 根据给出的地址个数，分为三、二、单、零地址指令 三：双目运算符两个源操作数地址和一个结果地址 二：双目运算符两个源操作数，其中一个作为结果地址 一：（取反/负）既是操作数地址也是结果地址 零地址：一种是无需，or栈型指令的操作数在栈顶，故不需要 指令格式设计原则 指令尽量短 足够操作码位数 指令长度是字节的整数倍 合理选择地址字段个数 指令应尽量规整 指令系统设计 完备性完整性（指令的操作类型） 兼容性（兼容以前机器的指令） 均匀性（多种数据类型eg：三种整型，两种浮点） 可扩充性（预留一定编码空间，方便扩充） 基本设计问题操作数类型 指针以及地址 数值数据 位、位串、字符以及字符串 *寻址方式 注意，一条指令若有两个或两个以上的地址码时，各地址码可采用不同的寻址方式。例如，源地址采用一种寻址方式，而目的地址采用另一种寻址方式。 立即寻址：指令直接给出操作数本身 直接寻址：指令中给出操作数的有效地址（直接/绝对地址） 间接寻址：给出操作数的地址的地址（可多重） 寄存器寻址：地址码是操作数所在寄存器编号 寄存器地址断，故寄存器寻址指令短 操作数已经在cpu，不访存，速度快 寄存器间接寻址：寄存器中存放操作数的有效地址，需要访存 变址寻址：线性表等，给出基准地址，（变址寄存器 I ）给出偏移量 把变址寄存器Rx的内容与指令中给出的形式地址A相加，形成操作数有效地址，即EA=(Rx)+A。Rx的内容称为变址值。S=((Rx)+A) 相对寻址：相对寻址是基址寻址的一种变通，由程序计数器PC提供基准地址，指令中的地址码字段作为位移量D，两者相加后得到操作数的有效地址，即 EA=(PC)+D。位移量指出的是操作数和现行指令之间的相对位置。 相对寻址方式的特点： 操作数的地址不是固定的，它随着PC值的变化而变化，并且与指令地址之间总是相差一个固定值±D。当指令地址改变时，由于其位移量不变，使得操作数与指令在可用的存储区内一起移动，所以仍能保证程序的正确执行。采用PC相对寻址方式编写的程序可在主存中任意浮动，它放在主存的任何地方，所执行的效果都是一样的。 由于指令中给出的位移量可正、可负，所以对于指令地址而言，操作数地址可能在指令地址之前或之后。 8. 基址寻址：基址寄存器Rb的内容与指令中给出的位移量D相加，形成操作数有效地址，即EA=(Rb)+D。基址寄存器的内容称为基址值。指令的地址码字段是一个位移量，位移量可正、可负。 S=((Rb)+D) Conclution寻址方式指如何在指令中表示要访问的内存地址。表2.4列出了计算机中常用的寻址方式，其中数组mem表示存储器，数组regs表示寄存器，mem[regs[Rn]]表示由寄存器Rn的值作为存储器地址所访问的存储器值。 表 2.4: 常用寻址方式 寻址方式 格式 含义 寄存器寻址（Register） ADD R1,R2 regs[R1]=regs[R1]+regs[R2] 立即数寻址（Immediate） ADD R1,#2 regs[R1]=regs[R1]+2 偏移量寻址（Displacement） ADD R1,100(R2) regs[R1]=regs[R1]+mem[100+regs[R2]] 寄存器间接寻址（Reg.Indirect） ADD R1,(R2) regs[R1]=regs[R1]+mem[regs[R2]] 变址寻址（Indexed） ADD R1,(R2+R3) regs[R1]=regs[R1]+mem[regs[R2]+regs[R3]] 绝对寻址（Absolute） ADD R1,(100) regs[R1]=regs[R1]+mem[100] 存储器间接寻址（Mem.Indirect） ADD R1,@(R2) regs[R1]=regs[R1]+mem[mem[regs[R2]]] 自增量寻址（Autoincrement） ADD R1,(R2)+ regs[R1]=regs[R1]+mem[regs[R2]],regs[R2]=regs[R2]+d 自减量寻址（Autodecrement） ADD R1,-(R2) regs[R2]=regs[R2]-d,regs[R1]=regs[R1]+mem[regs[R2]] 比例变址寻址（Scaled） ADD R1,100(R2)(R3) *regs[R1]=regs[R1]+mem[100+regs[R2]+regs[R3]d] 操作类型 算数和逻辑运算指令：加减乘除/比较/加一减一/位运算 移位指令 传送指令 串指令 顺序控制指令：转移、跳转、跳步、调用、返回 CPU控制指令 输入输出指令 操作码编码 定长操作码编码： 长度固定，译码方便，执行指令速度快，但有信息冗余。 扩展操作码编码： 几种固定长度的格式，4-8-12，3-6-9等，多用于非规整性指令集 异常以及中断处理异常 exception：也称为例外，执行时cpu内部发生的。 故障：遇到终止程序执行。 自陷：人为埋设，例如断点、单步追踪，处理结束返回下条继续执行。 终止：特殊事件，每条指令执行完都检查有无中断指令，有则将 下条指令作为断点保存，并转到相应断点服务执行，结束后返回断点继续。 终止与指令执行无关，由CPU外部的I/O部件通过专门的中断请求线向CPU请求 程序的机器级表示略","link":"/2024/04/01/%E8%AE%A1%E7%BB%84Chapter4/"},{"title":"费曼技巧","text":"所谓的“费曼技巧”，来源模糊，需要调查确认，在网上找到了两项证据，可以支持**【** **通过向别人清楚地解说一件事，来确认自己真的弄懂了这件事。** **】** ，但费曼本人是否提出过【费曼技巧】，尚未找到证据。无论如何，**上网时请不要轻信未经证实的信息。** 知乎原文 费曼和他的老师曾经提倡过“以教促学” 原文来自 Quora: 如何才能学得快一些 (How can you learn faster) 第一步 - 选择一个你想要理解的概念选择一个你想要理解的概念, 然后拿出一张白纸, 把这个概念写在白纸的最上边. 第二步 - 设想一种场景，你正要向别人传授这个概念在白纸上写下你对这个概念的解释, 就好像你正在教导一位新接触这个概念的学生一样. 当你这样做的时候, 你会更清楚地意识到关于这个概念你理解了多少, 以及是否还存在理解不清的地方. 第三步 - 如果你感觉卡壳了, 就回顾一下学习资料无论何时你感觉卡壳了, 都要回到原始的学习资料并重新学习让你感到卡壳的那部分, 直到你领会得足够顺畅, 顺畅到可以在纸上解释这个部分为止.第四步 - 为了让你的讲解通俗易懂，简化语言表达最终的目的, 是用你自己的语言, 而不是学习资料中的语言来解释概念. 如果你的解释很冗长或者令人迷惑, 那就说明你对概念的理解可能并没有你自己想象得那么顺畅 – 你要努力简化语言表达, 或者与已有的知识建立一种类比关系, 以便更好地理解它。","link":"/2024/03/17/%E8%B4%B9%E6%9B%BC%E6%8A%80%E5%B7%A7/"},{"title":"Vmware 无ui启动&#x2F;停止 虚拟机","text":"Vmware 无ui启动/停止 虚拟机 , 并优化启动速度 虚拟机设置中 3d加速-&gt; 关闭（没有图形界面打开这个会导致加载很慢） windows(win10)批处理脚本 打开vm虚拟机的服务,并且开启无界面虚拟机 123456789101112131415@echo offnet start &quot;vds&quot;net start &quot;VMAuthdService&quot;net start &quot;VMnetDHCP&quot;net start &quot;VMware NAT Service&quot;net start &quot;VMUSBArbService&quot;net start &quot;VMwareHostd&quot;&quot;D:\\ApplicationFiles\\System\\VMware Workstation\\vmrun.exe&quot; start &quot;F:\\virtualMachine\\ubuntu15.1X64\\ubuntu15.1X64.vmx&quot; nogui 保存为startvm.bat 1234567891011121314151617@echo off&quot;D:\\ApplicationFiles\\System\\VMware Workstation\\vmrun.exe&quot; stop &quot;F:\\virtualMachine\\ubuntu15.1X64\\ubuntu15.1X64.vmx&quot; noguinet stop &quot;vds&quot;net stop &quot;VMnetDHCP&quot;net stop &quot;VMware NAT Service&quot;net stop &quot;VMwareHostd&quot;net stop &quot;VMUSBArbService&quot;net stop &quot;VMAuthdService&quot;保存为shutdownvm.bat 说明: D:\\ApplicationFiles\\System\\VMware Workstation\\vmrun.exe 为虚拟机安装目录/ps:如果你把vmrun路径加入了环境变量path后,可以直接使用命令vmrun F:\\virtualMachine\\ubuntu15.1X64\\ubuntu15.1X64.vmx 为虚拟机文件位置 生成的文件创建快捷方式,右键-属性-高级,设置下管理员权限运行,以后双击即可执行 打开还要等个一分钟左右启动好,具体看你的系统性能 接下来就可以正常ssh连接了 下面重点说一下用到的知识点原理 一,首先说一下,window上面如何操作服务(win10 x64) windows上使用sc命令net命令设置操作服务,批处理关闭服务命令 开启服务命令 使用sc命令： 1 修改服务启动类型 sc config 服务名 start= demand (设置服务为手动启动) start= auto (设置服务为自动启动) start= disabled (设置服务为禁用) 2 安装服务：sc create 服务名 3 停止服务：sc stop 服务名 4 启动服务 : sc start 服务名 5 卸载服务：sc delete 服务名（卸载前先停止服务） 使用net命令 查看运行的服务： net start 启动服务： net start 服务名 停止服务： net stop 服务名 卸载服务： 服务名 -uninstall （卸载前先停止服务） 注意注意注意: start后面不能有空格 =后面的参数需要有一个空格 不是一个单词（含空格）的服务名字,需要用引号 综上所述我们可以使用: 启动服务： net start 服务名 或者 sc start 服务名 停止服务： net stop 服务名 或者 sc stop 服务名","link":"/2024/04/13/Vmware-UbuntuServer-noui-install/"},{"title":"ununtu安装node.js_LTS","text":"ubuntu 安装 LTS 版本 Node.js ubuntu 安装 LTS 版本 Node.js今天在服务器上安装 Node.js ，用了下面的命令： 12$ sudo apt-get update$ sudo apt-get install nodejs 结果看了下安装的版本居然是 10.x 的，现在 LTS 版本都是 14.x 了，怎么才能安装 LTS 版本呢？网上搜了下可以在安装的时候指定版本： 1$ sudo apt install nodejs=14.18.1 但是执行却提示找不到版本： Version ‘14.18.1’ for ‘nodejs’ was not found 又到网上查了下，原来是要添加源之后安装： 1$ curl -sL https://deb.nodesource.com/setup_14.x | sudo -E bash - 这里添加的是 14.x 的版本，如果安装其他版本，只需要修改添加源地址的数字即可 再次尝试安装： 1$ sudo apt-get install -y nodejs 安装成功，查看版本号： 12$ node -v # v14.18.1$ npm -v # 6.14.15","link":"/2024/04/13/ununtu%E5%AE%89%E8%A3%85node-js-LTS/"},{"title":"ununtu_shell_tools","text":"ubuntu 常用的shell命令合集 Linux终端命令ubuntu安装插件命令12sudo apt-get install 插件名称(tree)1 查看硬盘容量信息1234df -h#查看当前目录文件夹占用磁盘空间du -sh *123 查看内存使用情况123cat /proc/meminfofree -h12 查看当前目录12pwd1 创建文件(创建file.txt文件)12touch file.txt1 查看帮助文档1234command --helpman command123 ls命令 选项 说明 -a 显示隐藏文件（以.开头的文件） -l 显示文件详细信息 -h 显示文件大小 需要配合-l选项使用 ls通配符 通配符 说明 * 代表任意个数字符 ? 代表一个字符 [] 标识匹配字符数组中的任意一个 [abc] 匹配a、b、c中任意一个字符 [a-f] [0-9] 匹配a到f范围内的任意一个字符 mkdir递归创建文件夹12mkdir -p dir1/dir2/dir31 rm命令 选项 说明 -r 递归删除 -f 强制删除。忽略不存在的文件，不提示确认 -d 删除空目录 拷贝和移动文件1、tree [目录名]: 以树状图列出文件目录结构 选项 说明 -d 只显示目录 2、cp 源文件 目标文件: 复制文件或者目录 选项 说明 -i 覆盖文件前提示 -r 递归复制该目录下所有子目录和文件，目标文件必须是一个目录名 3、mv 源文件 目标文件: 选项 说明 -i 覆盖文件前提示 查看文件内容1、cat 文件名: 查看文件内容、创建文件、文件合并、追加文件内容等功能（一次完整显示） 选项 说明 -b 对非空行编号 -n 对所有行编号 2、more 文件名: 分屏显示文件内容（分屏显示） 操作键 说明 空格 下一屏 enter 下一行 b 回滚一屏 f 前滚一屏 q 退出 /搜索字符串 搜索 3、grep 搜索内容（搜索内容有关键词、空格需要加上双引号） 文件名: 搜索文本文件内容 选项 说明 -n 显示行号 -v 显示不包含匹配文本的所有行 -i 忽略大小写 常用的两种模式查找 ^a：行首，搜索以a开头的行 d$：行尾，搜索以d结尾的行 其他命令1、echo 文字内容 echo会在终端中显示参数指定的文字,通常会和重定向联合使用 2、重定向&gt;和&gt;&gt; 表示输出，会覆盖文件原有的内容 （将终端中输入的内容输出到文件中） 表示追加，会将内容追加到已有文件的末尾（将终端中输入的内容追加到文件末尾） 所有命令终端输出结果都可以使用&gt;和&gt;&gt;重定向到文件中例如 3、管道| Linux允许将一个命令的输出可以通过管道做为另一个命令的输入 可以理解现实生活中的管子，管子的一头塞东西进去，另一头取出来，这里的左右分为两端，左端塞东西(写)，右端取东西(读) 常用的管道命令有: more: 分屏显示内容 grep: 在命令执行结果的基础上查询指定的文本 远程管理常用命令关机重启1234567shutdown [选项] [时间]# 选项 -r 重新启动showdown -t now shutdown 20:10shutdown +10 #10分钟后关机shutdown -c #取消关机123456 查看网卡信息1234ip aip addressifconfig123 ssh命令(远程连接)123ssh [-p 端口号] 用户名@ip(或者域名)ssh root@ip12 scp(远程复制文件)1234scp [-P 端口号] 文件名称或路径 用户名@ip(或者域名):路径 # 复制本地文件到远程服务器# 选项 -r 若给出的源文件是目录文件 则scp将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名scp D:\\dir\\s.txt root@ip:/tmp123 123scp [-p 端口号] 用户名@ip(或者域名):文件名称或路径 路径 # 复制远程服务器文件到本地scp zhaosc@192.168.174.129:/home/zhaosc/demo/demo.txt D:\\12 注：要确认安装ssh服务端和客户端 123sudo apt-get install openssh-server# 安装服务端12 ssh高级免密码登录 home目录下 .ssh隐藏文件夹 known_hosts文件存储授权信息 1231、配置公钥 执行ssh-keygen即可生成SSH钥匙，一路回车即可12 id_rsa 和 id_rsa.pub 远程登陆时用来加密使用的文件 12342、上传公钥到服务器(id_rsa.pub) 执行ssh-copy-id -p port user@remote ，可以让远程服务器记住我们的公钥 ssh-copy-id -p 22 root@47.117.64.2123 本地使用私钥对数据进行加密/解密 服务器使用公钥对数据进行加密 以上命令在本地客户端执行 需要将本地客户端公钥（id_rsa.pub）添加到远程服务端的 ~/.ssh/authorized_keys中（可以手动添加，注意单行添加） 配置别名（在本地客服端创建 .ssh/config）12345678910111213.ssh/config配置信息如下---------------------------------Host aly # 别名 HostName ip # ip/域名 User root # 用户名 Port 22 # 端口号----------------------------------登录ssh aly复制文件scp -r aly:/usr/local/tomcat/webapps D:\\---------------------------------123456789101112 用户和权限ls -l 权限信息： 文件 -开头； 文件夹 d开头 ；r可读w可写x可执行 权限列为三列(三个一组) 依次是 用户权限 组权限 其他用户权限 用户和组信息： 前面为用户后面为组 chmod命令12chmod +/- rwx1 用户组管理123groupadd 组名 # 添加组groupdel 组名 # 删除组12","link":"/2024/04/13/ununtu-shell-tools/"}],"tags":[{"name":"aira2","slug":"aira2","link":"/tags/aira2/"},{"name":"刷机","slug":"刷机","link":"/tags/%E5%88%B7%E6%9C%BA/"},{"name":"icarus","slug":"icarus","link":"/tags/icarus/"},{"name":"LLM","slug":"LLM","link":"/tags/LLM/"},{"name":"AI","slug":"AI","link":"/tags/AI/"},{"name":"GPT","slug":"GPT","link":"/tags/GPT/"},{"name":"环境配置","slug":"环境配置","link":"/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"name":"cpp","slug":"cpp","link":"/tags/cpp/"},{"name":"stl","slug":"stl","link":"/tags/stl/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"verilog","slug":"verilog","link":"/tags/verilog/"},{"name":"vscode","slug":"vscode","link":"/tags/vscode/"},{"name":"破解软件","slug":"破解软件","link":"/tags/%E7%A0%B4%E8%A7%A3%E8%BD%AF%E4%BB%B6/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"Icarus","slug":"Icarus","link":"/tags/Icarus/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"codespace","slug":"codespace","link":"/tags/codespace/"},{"name":"quartus","slug":"quartus","link":"/tags/quartus/"},{"name":"modelsim","slug":"modelsim","link":"/tags/modelsim/"},{"name":"c++","slug":"c","link":"/tags/c/"},{"name":"markdown","slug":"markdown","link":"/tags/markdown/"},{"name":"计算机组成原理","slug":"计算机组成原理","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"name":"笔记","slug":"笔记","link":"/tags/%E7%AC%94%E8%AE%B0/"},{"name":"ubuntu","slug":"ubuntu","link":"/tags/ubuntu/"}],"categories":[],"pages":[{"title":"About","text":"ABC项目 2017年01月 aaa","link":"/AboutMe/index.html"}]}