{"posts":[{"title":"Windows 万能下载器 Aira2 懒人配置：","text":"Aria2 是一个命令行全功能下载器，同时支持磁力下载，没有原生界面但是可以使用aira2c以及airaNG的web界面 为什么选择 Aria2？ Aria2 下载功能比较全面，支持 BT 和磁力链接，性能也相当不错，速度不比迅雷慢。 虽然没有原生应用界面，配置也比较麻烦，但这些可以通过懒人包轻松解决。 最快速的懒人配置： 下载懒人包： LINK 将懒人包解压到 想要的文件夹，根据路径配置aria2.conf 官网下载 Aria2 程序LINK，然后解压到快速设置包的存放文件夹中，整体替代其中的 aria2相关程序和文件。 点击 Aria2c启动器.exeorAriaNg启动器.exe即可开始下载。两者都仅为前端界面，使用文件中的aria2.exe服务，可同时启动。包内均为开源绿色软件，不涉及任何隐私和安装，AutoHotkey 插件容易被误报。 Aria2c webui：https://aria2c.com/ AriaNg webui:file:///D:/Program/aria2/AriaNg/index.html#!/downloading 接管浏览器下载如果想用 Aria2 接管浏览器的下载管理，需安装插件/扩展。 Chrome：安装 添加到 aria2 扩展。下载包可以用 国内搬运地址，或是懒人包内置文件。如果浏览器无法直接安装 .crx 格式的扩展，可以将文件解压到新文件夹「xxx」，然后在浏览器的地址栏输入 chrome://extensions/ 开启开发者模式，点击加载已解压的扩展程序，选中刚才解压的文件夹「xxx」。 Firefox：安装 Aria2 Download Manager Integration 扩展，可参考下方的 Chrome 扩展设置进行配置。 安装完「添加到 aria2」扩展后，右键扩展图标，点击「选项」&gt;「设置」，设置如下： 最小监视：10 M，低于该容量将由浏览器下载。如果 Aria2 要接手所有下载，可以将最小监视设为 0.001。JSON-RPC 链接：http://localhost:6800/jsonrpc。注意：「添加到 aria2」图标显示的 en 表示处于开启状态，dis 表示处于关闭状态，点击图标可以切换使用状态。","link":"/2024/03/04/Aira2%20%E6%87%92%E4%BA%BA%E9%85%8D%E7%BD%AE/"},{"title":"c++ STL 库 （未完成）","text":"c++ STL 库包含基本的图，列表，栈等数据结构以及基本操作，方便使用。 结构图 set（集合） 内部自动有序 不含重复元素 容器 1234567#include &lt;set&gt;set&lt;int&gt; name;set&lt;double&gt; name;set&lt;char&gt; name;set&lt;struct node&gt; name;set&lt;set&lt;int&gt; &gt; name;//注意：&gt; &gt;之间要加空格set&lt;int&gt; arr[10]; set容器内元素的访问set只能通过迭代器(iterator)访问(除了vector和string之外的STL容器都不支持*(it+i)的访问方式) ： 12set&lt;int&gt;::iterator it;set&lt;char&gt;::iterator it; 1234for (set&lt;int&gt;::iterator it = st.begin(); it != st.end(); it++){ cout &lt;&lt; *it &lt;&lt; endl;} 常用函数insert(value)1st.insert('C'); find(value)find(value)返回的是set中value所对应的迭代器，也就是value的指针（地址） 1cout &lt;&lt; *(st.find(2)) &lt;&lt; endl; erase(it)1st.erase(st.find(100)); //利用find()函数找到100,然后用erase删除它 erase(iteratorBegin , iteratorEnd)左闭右开 1st.erase(it, st.end()); size()1cout &lt;&lt; st.size() &lt;&lt; endl; vector（矢量） 变长数组 123456789#include &lt;vector&gt;vector&lt;int&gt; name;vector&lt;double&gt; name;vector&lt;char&gt; name;vector&lt;struct node&gt; name;vector&lt;vector&lt;int&gt; &gt; name;//注意：&gt; &gt;之间要加空格vector&lt;int&gt; array[SZIE]; //二维变长数组 二维数组中，它的一维形式就是地址。例如： 12int arr[3][2];//定义一个3行2列的地址cout&lt;&lt;arr[0]&lt;&lt;endl; //输出arr第1行的地址 output: 10x61fe00 //arr第1行的地址 vector容器内元素的访问（1）通过下标访问 1cout&lt;&lt;vi[0]&lt;&lt;endl; （2）通过迭代器访问 迭代器（iterator）可以理解为指针 123456789101112131415161718192021222324vector&lt;类型名&gt;::iterator 变量名;vector&lt;int&gt;::iterator it;vector&lt;double&gt;::iterator it; vector&lt;int&gt;::iterator it=v.begin(); for (int i = 0; i &lt; v.size(); i++) { cout&lt;&lt;it[i]&lt;&lt;&quot; &quot;; } vector&lt;int&gt;::iterator it=v.begin(); for (int i = 0; i &lt; v.size(); i++) { cout&lt;&lt;*(it+i)&lt;&lt;&quot; &quot;; } //vector的迭代器不支持it&lt;v.end()的写法，因此循环条件只能it!=v.end() for (vector&lt;int&gt;::iterator it=v.begin(); it!=v.end();it++) { cout&lt;&lt;*it&lt;&lt;&quot; &quot;; } vector常用函数实例解析（1）push_back(item)1v.push_back(i); （2）void pop_back()1v.push_back(i); （3）size()1cout&lt;&lt;v.size()&lt;&lt;endl; （4）clear()1v.clear(); （5）insert()123insert(__position,__x);v.insert(v.begin()+2,-1); //将-1插入v[2]的位置 （6）erase() 左闭右开12345erase(__position); //删除一个元素 v.erase(v.begin()+3);erase(__positionBegin,__positionEnd);//删除一个区间内的元素 v.erase(v.begin()+1,v.begin()+4);","link":"/2024/02/28/c++%20STL%20%E5%BA%93/"},{"title":"Verilog running in vscode","text":"尝试在vscode跑Verilog，记录一下。很久之前设置的，想到多少写多少吧： 一·添加的扩展：Verilog HDL：添加一个运行按钮，添加控制台输出（大概） Verilog Snippet：关键词高亮补全（大概） Verilog_Testbench：自动生成测试文件，用处不大。 Verilog-HDL/SystemVe：主要的，综合各个模块 WaveTrace：波形显示 二·部分设置：&quot;verilog.linting.linter&quot;: &quot;iverilog&quot; 三·报错：1.include 报错：`include “./my.v”找不到文件，使用相对绝对路径都不行：设置为：&quot;verilog.linting.iverilog.runAtFileLocation&quot;: true","link":"/2023/10/18/verilog-in-vscode/"},{"title":"使用giscus为blog添加评论系统","text":"giscus指一个非常好用的由GitHub讨论支持的评论系统，它可以让你把仓库中的讨论整合到你的博客中。 如何使用 GitHub 讨论作为聊天系统为了将GitHub讨论整合到你的博客，我们将使用 giscus。giscus是一个由GitHub讨论支持的评论系统。它可以让你把仓库中的讨论整合到你的博客中。 你的读者可以在你的博客上留下评论，这些评论会同时出现在你的博客和你的代码库的讨论页面上。 使用讨论区作为你的博客聊天系统的优势 它是完全免费的 没有广告或跟踪 它超级强大 你对评论有完全的控制权和完全的修改权。 有很多主题 它是相当可自定义的 你可以在你自己的服务器上自行托管 请记住，此工具主要适用于开发者博客，因为大多数开发人员使用 GitHub。 如何在你的博客中整合giscus先决条件 一个博客（你必须能够获得源代码） 一个 GitHub 帐户 你选择的代码库必须是公开的 首先，你需要为你的代码库启用讨论功能。 转到代码库 Settings-&gt; 在 Features部分下 -&gt; 勾选 Discussions框。接下来，在你的代码库中安装giscus应用程序。转到 giscus主页，按照提示操作，并仅授予对选定代码库的访问权限。现在是重要的部分：我们需要配置giscus小部件。 首先，进入giscus主页，滚动到 Configuration部分。 选择您的小部件语言，这是您想要显示小部件的语言。然后输入你的代码库名称和你的用户名，如用 username/reponame。对于页面↔️讨论映射，我建议选择 “讨论标题包含页面 URL”。但根据你的需要，选择最适合你的那一个。接下来，在你的GitHub 代码库上的讨论页面创建一个类别——比如 “Comments（评论）”——或者选择现有的类别。然后根据需要启用可选功能。 接下来，选择主题。不要担心，你可以通过编程来切换不同的主题。 最后，复制并粘贴生成的代码。 Giscus将根据你的设置生成一个脚本标签，你可以将其粘贴到你的代码中。","link":"/2024/03/08/%E4%BD%BF%E7%94%A8giscus%E4%B8%BAblog%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/"},{"title":"使用github codespace + github page + hexo 无服务器发布运行个人博客","text":"hexo是一个可以github page 托管的静态页面博客框架，需要node.js进行编译发布，鉴于windows配置node.js的不变性，使用github codespace托管运行环境以及博客源码，进行无服务器博客运营。 icarus 主题 整体颜色改变：/node_modules/hexo-theme-icarus/include/style/base.styll15 $primary ?= hsl(30, 100%, 50%) 更改两栏布局下文章宽度 部分更改 调整背景透明度themes\\icarus\\source\\js\\animation.jsL44 https://blog.mchook.cn/2021/07/22/icarus%E4%B8%BB%E9%A2%98%E8%87%AA%E5%AE%9A%E4%B9%89/https://blog.pk5ls20.com/posts/111d57cd/#span-%E8%83%8C%E6%99%AF%E5%9B%BE%E5%85%A8%E5%B1%8F%E5%8C%96-%E6%AF%9B%E7%8E%BB%E7%92%83%E6%95%88%E6%9E%9C-span 我使用的布局：.is-3-colum","link":"/2024/03/09/%E4%BD%BF%E7%94%A8github-codespace-github-page-hexo-%E7%BA%BF%E4%B8%8A%E7%BC%96%E8%BE%91%E5%8F%91%E5%B8%83%E8%BF%90%E8%A1%8C%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"title":"样式测试","text":"这是一个简单的样式测试页面 主题1主题2主题3主题4主题5细细细细 粗体粗体粗体粗体粗体 细细细细细细 斜体斜体 删除删除删除删除删除 下划线下划线下划线下划线 引用引用引用引用 hangneidaima行内代码` 12345代码块代码块代码块代码块代码块代码块 无序列表 无序列表 无序列表 无序列表、 有序列表 有序列表 有序列表 有序列表 链接链接链接链接 @提及提及提及提及提及","link":"/2024/03/07/%E6%A0%B7%E5%BC%8F%E6%B5%8B%E8%AF%95/"},{"title":"Icarus主题的一些常用配置","text":"常见的一些配置见_config.icarus.yml，英文不差都能看懂，或者去看icarus文档。本文主要就是一些网上很少的配置。 Icarus: 4.0.0 文章页面两栏布局在 _config.icarus.yml目录下，创建 _config.post.yml文件，该文件内容与 _config.icarus.yml文件一样，用于单独加载post界面布局。注意，双栏需要将widgets内容的position都设置为同一边。 12345678910111213141516171819202122232425262728# 单独文章界面布局widgets: # 个人信息 - position: left type: profile author: zhaommmmomo author_title: fahaxiki! location: Yantai,China avatar: /img/logo.jpg avatar_rounded: false follow_link: 'https://zhaommmmomo.cn' social_links: Github: icon: fab fa-github url: 'https://github.com/zhaommmmomo' # 文章目录 - position: left type: toc # 目录序号 index: true# 侧边栏是否固定sidebar: left: sticky: false right: sticky: false 增加两栏布局下文章的宽度12345678910111213141516171819202122232425262728# layout/layout.jsxmodule.exports = class extends Component { render() { ...... &lt;Head site={site} config={config} helper={helper} page={page} /&gt; # &lt;body class={`is-${columnCount}-column`}&gt; 修改为下面一行 &lt;body class={`is-3-column`}&gt; ...... # 'is-8-tablet is-8-desktop is-8-widescreen': columnCount === 2 # 修改为下面一行 'is-8-tablet is-8-desktop is-9-widescreen': columnCount === 2, 'is-8-tablet is-8-desktop is-6-widescreen': columnCount === 3 })} dangerouslySetInnerHTML={{ __html: body }}&gt;&lt;/div&gt; ...... }};# layout/common/widgets.jsxfunction getColumnSizeClass(columnCount) { switch (columnCount) { case 2: # return 'is-4-tablet is-4-desktop is-4-widescreen'; # 修改为下面一行 return 'is-4-tablet is-4-desktop is-3-widescreen'; case 3: return 'is-4-tablet is-4-desktop is-3-widescreen'; }} 只固定目录123456# source/js/main.jsconst $toc = $('#toc');if ($toc.length &gt; 0) { $toc.addClass('column-left is-sticky'); # 添加 ......} 1234# include/style/widget.styl 添加下面#toc max-height: calc(100vh - 22px) overflow-y: scroll","link":"/2024/03/10/Icarus%E4%B8%BB%E9%A2%98%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/"},{"title":"从C++到python","text":"python的优点是简单易学，库安装简单配置丰富，写法简洁，本文目的即初步认识python的规则化写法。 环境安装 进入’https://www.jetbrains.com/pycharm/‘ 下载pycharm并安装。 根据引导安装应用并登录，创建你的第一段python代码。 差异 毋庸置疑，py比cpp更简单，写代码形式上亦是如此，大体上差别如下： 不需要头文件 主函数没有函数名 不需要{} 不需要; 接下来，从最简单的输出开始； 基本知识输入输出输出函数print()语法就是： 1print() 输入函数是 input()，功能是接收用户输入的内容，语法是： 1input（输出的内容） 举例：接收用户输入的密码并打印: 12n = input(&quot;请输入密码：&quot;) #把输入内容赋给n，用 n 接收一下print(n) #打印n 在Python里，“#” 表示注释，“#”后面的东西不会被执行。 123提示信息请输入密码：123123 变量 合法的标识符:大小写字母，数字(不能开头),下划线。 没有长度限制。 建议望文生义，函数名、变量名等命名方法各有区分： 123451. 包名：全小写，例如 time ;2. 类名：每个单词的首字母大写，其他的小写，简称大驼峰命名，例如 HelloWorld ；3. 变量名/函数名:第一个单词的首字母小写，后面的单词的首字母大写，简称小驼峰命名，例如 helloWorld ；4. 常量：全大写，例如 HELLO 。5. 其他命名方式，比如 hello_world 。 数据类型与c++不同，python不需要类型说明符，在设置时会自行分配。（不是没有!!!） 整型 浮点型 字符串 bool类型 None 是一个单独的数据类型 列表、元组、字典、集合也是常见的数据类型 类型转换：123int() #被转换的必须为全数字的字符串str()float() #被转换的必须为全数字的字符串 获取类型信息1234type() #返回的是对象的类型type().__name__sinstance(,) #常用来判断数据类型,返回bool 例子：1234f = 30print(type(f))print(type(f).__name__) print(isinstance(f,int)) 输出：1234f = 30print(type(f))print(type(f).__name__)print(isinstance(f,float)) 运算符运算符可以分为很多4类 一般运算符 +，-，*，/（真除法）,//（地板除，舍去小数部分）,%（取余数）,**（幂运算） 赋值运算符 =,+=，-=，*=，/=,%=,**=连续赋值：a=b=c=d=10 布尔运算符 == （等于），！=（不等于）, &gt;= ,&lt;= ,&gt;, &lt; 4.逻辑运算符 主要有not、and和or三类，又称非、与和或 and：前后都为真则为真or：有一个为真则为真not:非真，非假 例子： 12345678a = 10b = 20c = 30d = 40n1 = a &gt; b and a &lt; c #a&gt;b为假，a&lt;c为真，假与真为假n2 = not a &lt; c #a&lt;c为真，非真则为假n3 = a &gt; b or a &lt; c #a&gt;b为假，a&lt;c为真，假或真为真print(n1,n2,n3) 输出; 1False False True 流程控制条件分支 (if elif else)例子： 12345678910111213s = int(input(&quot;请输入分数:&quot;))if 80 &gt;= s &gt;= 60: print(&quot;及格&quot;)elif 80 &lt; s &lt;= 90: print(&quot;优秀&quot;)elif 90 &lt; s &lt;= 100: print(&quot;非常优秀&quot;)else: print(&quot;不及格&quot;) if s &gt; 50: print(&quot;你的分数在60分左右&quot;) else: print(&quot;你的分数低于50分&quot;) 输出： 123请输入分数:55不及格你的分数在60分左右 循环流程 while循环 语法： 12while 布尔表达式: 代码块 只要条件(布尔表达式)为真就执行里面的代码块。 举例：比如说输入一个整数并计算各个位和，例如输入321，那么各个位之和则为6。 12345678910111213# 请输入一个整数，并计算各个位和 如：321=6n = int(input(&quot;请输入一个整数:&quot;)) # 将字符串转为整型# sums累加器：m=10 m=10+5sums = 0while n != 0: # 32 #3 sums = sums + n % 10 # sums=1+2=3+3=6 n = n // 10 # 32print(sums) 输出： 12请输入一个整数:234514 for循环 语法： 12for 变量 in 可迭代对象: 代码块 例子： 123l=[3,2,1]for n in l: print(&quot;1&quot;) 输出： 123111 range for循环经常会搭配range来使用，range是一个可迭代对象，range的语法如下： 1range(start=0,stop,step=1) Range对象返回一个对象，该对象按步生成从开始(包含)到结束(排除)的整数序列。Range (i, j)产生i, i+1, i+2，…j - 1。Start默认为0,stop省略! Range(4)产生0,1,2,3。这些正是包含4个元素的列表的有效索引。 当给出step时，它指定增量(或减量)。 continue break continue跳过本次循环，后面的循环继续执行break终止循环 列表(List)列表是可以同时存放任何数据，包括整型，浮点型，字符串，布尔型等等，是常用的数据类型之一。 列表的创建123456789列表也是一个可迭代对象1. 普通形式 l = [1,2,3,4,5] ---整型列表 l = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;] ---字符串列表 l = [True,False,1&gt;2,5&lt;6]---布尔列表2. 混合列表 l = [1,2.5,&quot;a&quot;,True]3. 空列表 l = [] 从列表中获取数据列表是有下标的，并且下标从0开始，获取方法类似数组但是列表的下标正序从0开始，倒叙从-1开始 print(List)顺序输出整个列表 列表中数据交换例子： 123l = [1, 2, 3, 4, 5] # 下标/索引：0开始l[2], l[3] = l[3], l[2]print(l) Output: 1[1, 2, 4, 3, 5] 向列表添加元素123append(project) #列表尾插对象（作为整体）extend(project) #列表尾插可迭代对象 eg：两列表相连接insert(num,project) #指定下标位置添加对象（作为整体） 列表删除元素1234clear()#清空列表（列表还在，没被删除）pop()#删除下标指定的元素，如果不加下标则删除最后一个元素remove()#删除（正序第一个）指定的对象del()#删除变量(整个列表)或列表指定下标元素的值（补位） 例子: 12345678910111213141516171819l = [1, 2, 3, 4, 5]l2=[6, 7, 8, 9, 10]l.extend(l2)print(l)l.append(l2)print(l)l.insert(3,l2)print(l)l.pop(1)print(l)l.remove(l2)print(l)del l[-1]print(l)del lprint(l2)l2.clear()print(l2) Output 12345678[1, 2, 3, 4, 5, 6, 7, 8, 9, 10][1, 2, 3, 4, 5, 6, 7, 8, 9, 10, [6, 7, 8, 9, 10]][1, 2, 3, [6, 7, 8, 9, 10], 4, 5, 6, 7, 8, 9, 10, [6, 7, 8, 9, 10]][1, 3, [6, 7, 8, 9, 10], 4, 5, 6, 7, 8, 9, 10, [6, 7, 8, 9, 10]][1, 3, 4, 5, 6, 7, 8, 9, 10, [6, 7, 8, 9, 10]][1, 3, 4, 5, 6, 7, 8, 9, 10][6, 7, 8, 9, 10][] 修改元素同数组。 列表高级特性切片操作切片，顾名思义就是把1个列表切分为多个列表，语法如下： 1变量[起始下标:结束下标] #结束下标取不到 做切片操作时要注意以下几个点： 如果下标从0开始可以省略不写，例如 n = l[:4]。 如果结束下标取的是最后一个元素，可以省略不写，例如 n = l[3:]。 如果列表中的元素都要，开始和结束下标都可以省略，例如 n = l[:]。 n = l[:-1] 表示从0开始 - 到数二个元素。例子： 12l = [1, 2, 3, 4, 5]print(l[0:4]) Output 1[1, 2, 3, 4] 等距抽取方法是 n = l[开始:结束:步长] ，这个方法既可以正向去操作列表，也可以反向去操作列表,例如: 123l = [1, 2, 3, 4, 5]n = l[-1:-3:-1]print(n) Output 1[5, 4] 列表的一些操作符比较运算符列表之间进行比较，以相同下标进行比较，从小到大进行比较，如果值相同则比较下一组元素，如果不同直接出结果，例如： 123l = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] # 下标/索引：0开始l2 = [2, 3, 4, 6]print(l &lt; l2) # True Output 1True 逻辑运算符逻辑运算符and not or 跟比较运算符相似，返回结果都是布尔值（True/False） 拼接运算符拼接运算符是 + ，常用来进行两个列表拼接 123l = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] # 下标/索引：0开始l2 = [2, 3, 4, 6]print(l + l2) 重复操作符重复操作符为 * ，后面常跟数字，表示将列表里面的元素重复复制几遍 12l2 = [2, 3, 4, 6]print(l2*2) 成员关系操作符成员关系操作符主要有 in和not in，用来判断元素是否在列表中，返回结果是布尔值 12l = [2, 3, 4, 6]print(5 not in l) #输出“5不在列表l中”这句话的真假 执行结果 1True 列表的其他方法123456copy()#浅拷贝count(project)#返回对象在列表中出现的次数index(value,开始下标,结束下标)#元素出现的第一次下标位置，也可自定义范围reverse()#原地翻转sort (key=None reverse=False)#快速排序，默认从小到大排序，key:算法len()#获取列表长度 二维列表12345#变量[外层列表下标][内层列表的下标]l = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]for i in l: for j in i: print(j) Output 123456789123456789 元组（tuple）元组的创建及访问 元组用（）的形式，是可迭代对象，是有序的，下标操作,支持切面操作 [:]同列表，不再赘述。 修改和删除元组是不可变类型，不能修改，但是可以通过将元组转换成列表的形式进行修改和删除等操作，最后再将列表转换成元组，完成元组的修改和删除。例如：修改元组中的元素: 1234567t = (1, 2, 3, 4, 5)l = list(t) #将元组转换成列表print(l) #输出列表l[2] = 6 #列表指定元素的修改print(l) #输出新列表t = tuple(l) #列表转换成元组print(t) Output 123[1, 2, 3, 4, 5][1, 2, 6, 4, 5](1, 2, 6, 4, 5) 元组的操作符元组同样也有着操作符，方法跟列表的操作符是一样的,不再赘述。 元组的方法对其操作先转换成列表再行操作，不再赘述。另外有两种方法新增： 123451. count(value)#统计某个值出现的次数，value是指定的值2. index(value,[start],[stop])#返回value在元组中(start到stop间)出现的下标位置（第一次出现的下标） 字符串在Python中，字符和字符串没有区别。可用' '也可以是” “ 字符串的特点1234567891. 字符串不可变类型2. 字符串是可迭代对象3. 字符串支持索引和切片操作4. 支持操作符; 拼接：+ 重复操作符：* 比较运算符： &gt; &lt; &lt;= &gt;= == != 逻辑运算符：not and or 成员关系： in not in 字符串的方法123456789capitalize()#把字符串的第一个字符改为大写，后面的小写casefold()#把整个字符串都小写encode()#编码 str--bytes (二进制字符串)decode()#解码count(sub,start, stop)#返回字符(sub)出现的次数，star: 开始下标，stop:结束下标find(sub,start,stop)# 返回sub第一次出现的下标,查不到返回-1index(sub, start, stop)#返回sub第一次出现的下标，查不到报错upper()#将字符串转为大写1ower()#将字符串转为小写 格式化输出 format 语法1：用数字占位（下标）12345&quot;{0} 嘿嘿&quot;.format(&quot;Python&quot;)a = 100s = &quot;{0}{1}{2} 嘿嘿&quot;s2 = s.format(a, &quot;JAVA&quot;, &quot;C++&quot;)print(s2) 2.format 语法2：{} 占位123456a = 100s = &quot;{}{}{} 嘿嘿&quot;s2 = s.format(a, &quot;JAVA&quot;, &quot;C++&quot;, &quot;C# &quot;)print(s2)#Output100JAVAC++ 嘿嘿 3.format 语法3：{} 占位用字母占位12345s = &quot;{a}{b}{c} 嘿嘿&quot;s2 = s.format(b=&quot;JAVA&quot;, a=&quot;C++&quot;, c=&quot;C# &quot;)print(s2)#Output:C++JAVAC# 嘿嘿 s.format(s2)可理解为使用s格式化s2 4.%s 语法为 “%s”%（值） ，最常用的参数可以是任意值。例子： 123456789101112131415for i in range(1, 10): for j in range(1, i + 1): print(&quot;%s * %s = %s&quot; % (i, j, i * j), end=&quot;\\t&quot;) print()#Output:1 * 1 = 1 2 * 1 = 2 2 * 2 = 4 3 * 1 = 3 3 * 2 = 6 3 * 3 = 9 4 * 1 = 4 4 * 2 = 8 4 * 3 = 12 4 * 4 = 16 5 * 1 = 5 5 * 2 = 10 5 * 3 = 15 5 * 4 = 20 5 * 5 = 25 6 * 1 = 6 6 * 2 = 12 6 * 3 = 18 6 * 4 = 24 6 * 5 = 30 6 * 6 = 36 7 * 1 = 7 7 * 2 = 14 7 * 3 = 21 7 * 4 = 28 7 * 5 = 35 7 * 6 = 42 7 * 7 = 49 8 * 1 = 8 8 * 2 = 16 8 * 3 = 24 8 * 4 = 32 8 * 5 = 40 8 * 6 = 48 8 * 7 = 56 8 * 8 = 64 9 * 1 = 9 9 * 2 = 18 9 * 3 = 27 9 * 4 = 36 9 * 5 = 45 9 * 6 = 54 9 * 7 = 63 9 * 8 = 72 9 * 9 = 81 转义字符12341. “\\n” ：换行符2. “\\'”:单引号3. “\\“”:双引号4. &quot;\\\\&quot; : \\ 在这里值得注意的是 \\ ，它有很多比较巧的运用，比如可以实现代码换行 12345678910111213a = &quot;sxsxsxsxsxsxsxs\\ xsxsxsxs\\ xsx&quot;print(a)a = 1 + 2 + 3 \\ + 4print(a)#Output:sxsxsxsxsxsxsxs xsxsxsxs xsx10 字典（dict）字典是用来存储数据的，字典中的数据以映射关系存储。 字典的特点 字典是Python中唯一的映射类型 字典是无序的 字典是可迭代对象 字典的构成: 键：key 值：value 映射：键映射值 键-值：键值对，又叫 项 创建字典1234561. 直接创建 语法： d = {} #空字典 例如： d = {&quot;name&quot;:&quot;不良人&quot;,&quot;apple&quot;:&quot;苹果&quot;}2. dict() 例如：d = dict() #空字典3. dict(可迭代对象) 例子： 1234d3 = dict([(&quot;one&quot;,1),(&quot;two&quot;,2)])print(d3)#Output：{'one': 1, 'two': 2} 这就是一个元组，one是键，1是值， ‘one’ : 1 是键值对。 14. dict(**kwargs) 例子： 1234d4 = dict(a=3, b=4)print(d4)#Output:{'a': 3, 'b': 4} 字典访问 基本形式： 变量名[键名] #键所对应的值 添加一个键值对 变量名[键名]=值 修改一个键值对的值 变量名[键名]=值 Example 1234d = {&quot;name&quot;: &quot;小黑&quot;}print(d[&quot;name&quot;])#Output:小黑 字典的方法","link":"/2023/07/01/%E4%BB%8EC-%E5%88%B0python/"},{"title":"Google服务异常耗电解决办法","text":"推荐root+gms doze.gms doze 卸载删不干净，还需要更改install.sh才能删除干净。gms doze 不工作则可能是系统或模块版本过低 原因：国内网状态下ping google服务器疯狂404并重试，导致占用率极大，手机温度达到温控阈值。 解决：1.gms doze（推荐）https://github.com/Magisk-Modules-Alt-Repo/GMSDoze 如果设备系统相同（lmi a13 pixel experience plus-2023-5-12），推荐使用，刷好后续航大幅度提升，配合scene的应用偏见功能完全可以将功耗发热降低至优于国内rom的水平 2.黑域动态gms: 有弹窗无法取消，并且root开机无法自启动，开发者给的答复是1.屏蔽弹窗消息不会支持。2.root不是主要支持，所以不会修。 3.universal gms doze：https://github.com/gloeyisk/universal-gms-doze 在我的设备（lmi a13 pixel experience plus-2023-5-12）不起作用 warning！模块由magisk刷入，所以能否卸载干净以及对设备的危害暂不知道！！！（底下的有人提出过相关issue，但是作者并未作答）","link":"/2023/06/30/Google%E6%9C%8D%E5%8A%A1%E5%BC%82%E5%B8%B8%E8%80%97%E7%94%B5%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"},{"title":"大学生创新创业大赛筹备","text":"备忘录，筹备答辩24/03/11 研究目的及研究内容研究目的 现在存在的研究的问题 本项目的改进点、创新点 研究内容结构图，简单概括PIC 国内外发展动态 传统方法，缺点介绍 近年发展3，本项目技术优点 项目创新点项目整体的优势 项目技术路线PIC整体路线分点介绍，小点实现 项目进度安排PIC 经费，小小展示一下表格 预期成果总结（结题）报告发论文专利（软著） 列一下就行 项目团队及已有基础 指导老师介绍（详细） 项目成员介绍 已有基础 已取得成绩 ：初步了解、初步确定、目前正在… 已具备实验条件：软件、数据集、老师可提供的帮助、硬件环境 答辩视频","link":"/2024/03/11/%E5%A4%A7%E5%AD%A6%E7%94%9F%E5%88%9B%E6%96%B0%E5%88%9B%E4%B8%9A%E5%A4%A7%E8%B5%9B%E7%AD%B9%E5%A4%87/"},{"title":"sym","text":"","link":"/2024/03/11/sym/"}],"tags":[{"name":"Icarus , blog","slug":"Icarus-blog","link":"/tags/Icarus-blog/"},{"name":"Icarus","slug":"Icarus","link":"/tags/Icarus/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"codespace","slug":"codespace","link":"/tags/codespace/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"cpp","slug":"cpp","link":"/tags/cpp/"},{"name":"stl","slug":"stl","link":"/tags/stl/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"aira2","slug":"aira2","link":"/tags/aira2/"},{"name":"S[aira2]","slug":"S-aira2","link":"/tags/S-aira2/"},{"name":"markdown","slug":"markdown","link":"/tags/markdown/"},{"name":"verilog","slug":"verilog","link":"/tags/verilog/"},{"name":"vscode","slug":"vscode","link":"/tags/vscode/"},{"name":"环境配置","slug":"环境配置","link":"/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"name":"icarus","slug":"icarus","link":"/tags/icarus/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"刷机","slug":"刷机","link":"/tags/%E5%88%B7%E6%9C%BA/"}],"categories":[],"pages":[{"title":"About","text":"ABC项目 2017年01月","link":"/AboutMe/index.html"}]}